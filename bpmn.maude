*** Ruben López Ranilla
*** Francisco de P. Arjona Jiménez

sload time.maude


fmod ID is 
	protecting STRING .

	sort Id .
	op id : String -> Id [ctor] .
endfm 

view Id from TRIV to ID is	
	sort Elt to Id .
endv

fmod NODE is 
	protecting SET{Id} .
	protecting STRING .
	protecting TIME .

	sort Gateway Node .
	subsort Gateway < Node .
	
	op exclusive : -> Gateway [ctor] .
	op parallel : -> Gateway [ctor] .
	op start : Id Id -> Node [ctor] .
	op end : Id Id -> Node [ctor] .
	op task : Id String Id Id Time Set{Id} -> Node [ctor] .
	op split : Id Gateway Id Set{Id} -> Node [ctor] .
	op merge : Id Gateway Set{Id} Id -> Node [ctor] .
endfm

view Node from TRIV to NODE is	
	sort Elt to Node .
endv


fmod RESOURCE is 
	protecting ID .

	sort Resource .
	op resource : Id Nat Nat -> Resource [ctor] .
endfm

view Resource from TRIV to RESOURCE is	
	sort Elt to Resource .
endv


fmod FLOW is 
	protecting ID .
	protecting TIME .

	sort Flow .
	op flow : Id Time -> Flow [ctor] .
endfm

view Flow from TRIV to FLOW is	
	sort Elt to Flow .
endv


fmod TOKEN is 
	protecting ID .
	protecting TIME .

	sort Token .
	op token : Id Time -> Token [ctor] .
endfm

view Token from TRIV to TOKEN is	
	sort Elt to Token .
endv


mod PROCESS is
	including CONFIGURATION .
	protecting POSRAT-TIME-DOMAIN-WITH-INF .
	protecting ID .
	protecting SET{Node} .
	protecting SET{Flow} .
	protecting SET{Token} .
	protecting SET{Resource} .

	--- class Process | nodes: Set{Node},
	---					flows: Set{Flow},
	---					tokens: Set{Token},
	---					gtime: Time,
	---					resources: Set{Resource} .

	sort Process .
	subsort Process < Cid .

	op Process : -> Process .
	op nodes:_ : Set{Node} -> Attribute [gather (&)] .
    op flows:_ : Set{Flow} -> Attribute [gather (&)] .
    op tokens:_ : Set{Token} -> Attribute [gather (&)] .
    op gtime:_ : Time -> Attribute [gather (&)] .
	op resources:_ : Set{Resource} -> Attribute [gather (&)] .
endm

mod BPMN-SEM is
	protecting PROCESS .

	var name : String .
	var N M : Nat .
	vars idnode idin idout idaux : Id .
	var O : Oid .
	var ids : Set{Id} .
	var nds : Set{Node} .
	var flws : Set{Flow} .
	var tks : Set{Token} .
	var rcs : Set{Resource} .
	var Atts : AttributeSet .
	vars T T' T'' Gtime : Time .

	--- advance of time over a configuration
	op delta : Set{Token} Time -> Set{Token} .
	eq delta(empty, T) = empty .
	eq delta((token(idnode, T'), tks), T) = (token(idnode, T' monus T),delta(tks, T)) .

	--- maximum time elapse (so that no event is lost)
	*** Las puertas necesitan tokens en sus flujos de entrada con timer = 0
	*** Las tareas necesitan tokens en sus flujos de entrada con timer = 0 y todos sus recursos especificados
	op mte : Configuration -> TimeInf .
	eq mte(none) = INF .
	eq mte(< O : Process | nodes: nds, 
							flows: flws, 
							tokens: empty, 
							Atts >) = INF .
	
	*** Token en la entrada de la task. Task con recursos no disponibles
	ceq mte(< O : Process | nodes: (task(idnode, name, idin, idout, T', ids),nds), 
							flows: (flow(idin, T'), flws), 
							tokens: (token(idin, T), tks), 
							Atts >)
		= minimum(INF, mte(< O : Process | nodes: (task(idnode, name, idin, idout, T', ids),nds), 
										   flows: (flow(idin, T'), flws), 
										   tokens: tks, 
										   Atts >)) 
		if resourcesAvailables(token(idin, T),< O : Process | nodes: (task(idnode, name, idin, idout, T', ids),nds), 
														flows: (flow(idin, T'), flws), 
														tokens: (token(idin, T), tks), 
														Atts >) == false .
	
	*** No es válido el token por el timer > 0
	ceq mte(< O : Process | nodes: (merge(idnode, parallel, (idin, ids), idout),nds), 
							flows: (flow(idin, T''), flws), 
							tokens: (token(idin, 0), tks), 
							Atts >) 
        = minimum(INF, mte(< O : Process | nodes: (merge(idnode, parallel, (idin, ids), idout),nds), 
											flows: (flow(idin, T''), flws), 
											tokens: tks, 
											Atts >)) 
        if tokensOnFlowsTime(idnode, < O : Process | nodes: (merge(idnode, parallel, (idin, ids), idout),nds), 
												flows: (flow(idin, T''), flws), 
												tokens: (token(idin, 0), tks), 
												Atts >) == false .
	
	eq mte(< O : Process | nodes: nds, flows: flws, tokens: (token(idnode, T), tks), Atts >)
		= minimum(T, mte(< O : Process | nodes: nds, flows: flws, tokens: tks, Atts >)) [owise].

	--- Operador para ver si los recursos de una task están disponibles
	op resourcesAvailables : Token Configuration -> Bool .
    eq resourcesAvailables(token(idin, 0), < O : Process | nodes: (task(idnode, name, idin, idout, T', empty), nds), 
													    resources: rcs,  
													    Atts >) 
					= true .

    ceq resourcesAvailables(token(idin, 0), < O : Process | nodes: (task(idnode, name, idin, idout, T', (idaux, ids)), nds), 
													     resources: (resource(idaux, N, M),rcs),  
													     Atts >) 
					= false if M = 0 .

    eq resourcesAvailables(token(idin, 0), < O : Process | nodes: (task(idnode, name, idin, idout, T', (idaux, ids)), nds), 
														  resources: (resource(idaux, N, M),rcs),  
														  Atts >) 
        			= resourcesAvailables(token(idin, 0), < O : Process | nodes: (task(idnode, name, idin, idout, T', ids), nds), 
														   resources: (resource(idaux, N, M),rcs),  
														   Atts >) [owise] . 

	--- Operador para ver si en los flujos de entrada hay un token con el tiempo a 0.
	op tokensOnFlowsTime : Id Configuration -> Bool .
	eq tokensOnFlowsTime(idnode, < O : Process | nodes: (merge(idnode, parallel, empty, idout), nds), 
											flows: (flow(idout, T'), flws), 
											tokens: tks, 
											Atts >) 
					= true .

	eq tokensOnFlowsTime(idnode, < O : Process | nodes: (merge(idnode, parallel, (idin, ids), idout), nds), 
											flows: (flow(idout, T'), flws), 
											tokens: tks, 
											Atts >) 
					= false .

    eq tokensOnFlowsTime(idnode, < O : Process | nodes: (merge(idnode, parallel, (idin, ids), idout), nds), 
											flows: (flow(idout, T'), flws), 
											tokens: (token(idin, 0), tks), 
											Atts >) 
       				= tokensOnFlowsTime(idnode, < O : Process | nodes: (merge(idnode, parallel, ids, idout), nds), 
														   flows: (flow(idout, T'), flws), 
														   tokens: tks, 
														   Atts >) [owise] .


	op addResource : Set{Id} Set{Resource} -> Set{Resource} .
	eq addResource(empty, rcs) = rcs . 
	eq addResource((idnode, ids), (resource(idnode, N, M),rcs)) = (resource(idnode, N, s M), addResource(ids, rcs)) .


	op removeResource : Set{Id} Set{Resource} -> Set{Resource} .
	eq removeResource(empty, rcs) = rcs .
	eq removeResource((idnode, ids), (resource(idnode, N, M),rcs)) = (resource(idnode, N, sd(M, 1)), removeResource(ids, rcs)) .


	op addTokens : Set{Id} Set{Flow} -> Set{Token} . 
    eq addTokens(empty, flws) = empty .
    eq addTokens((idnode, ids), (flow(idnode, T),flws)) = (token(idnode, T), addTokens(ids, flws)) . 
    
    op removeTokens : Set{Id} Set{Token} -> Set{Token} .
    eq removeTokens(empty, tks) = tks .
    eq removeTokens((idnode, ids), (token(idnode, T),tks)) = removeTokens(ids, tks) .



	--- tick rule should not advance time beyond expiration of a timer
	crl [tick] : < O : Process | tokens: tks, gtime: Gtime, Atts > 
		=> < O : Process | tokens: delta(tks, T'), gtime: Gtime plus T', Atts > 
		if T' := mte(< O : Process | tokens: tks, gtime: Gtime, Atts >) /\ 0 < T' /\ Gtime < 100 . 


	rl [start] : < O : Process | nodes: (start(idnode, idout), nds), 
								 flows: (flow(idout, T), flws), 
								 tokens: (token(idnode, 0), tks), 
								 Atts >
				=> < O : Process | nodes: (start(idnode, idout), nds), 
								   flows: (flow(idout, T), flws), 
								   tokens: (token(idout, T), tks), 
								   Atts > .


	crl [flowToTask] : < O : Process | nodes: (task(idnode, name, idin, idout, T, ids), nds), 
									   tokens: (token(idin, 0), tks), 
									   resources: rcs, 
									   Atts >
					=> < O : Process | nodes: (task(idnode, name, idin, idout, T, ids), nds), 
									   tokens: (token(idnode, T), tks), 
									   resources: removeResource(ids,rcs), 
									   Atts > 
					if resourcesAvailables(token(idin, 0), < O : Process | nodes: (task(idnode, name, idin, idout, T, ids), nds), 
																		   tokens: (token(idnode, 0), tks), 
																		   resources: rcs, 
																		   Atts >) .


	rl [task] : < O : Process | nodes: (task(idnode, name, idin, idout, T, ids), nds), 
								flows: (flow(idout, T'), flws), 
								tokens: (token(idnode, 0), tks), 
								resources: rcs, Atts >
					=> < O : Process | nodes: (task(idnode, name, idin, idout, T', ids), nds), 
									   flows: (flow(idout, T'), flws), 
									   tokens: (token(idout, T'), tks), 
									   resources: addResource(ids, rcs), 
									   Atts > .


	rl [end] : < O : Process | nodes: (end(idnode, idin), nds), 
							   flows: (flow(idin, T), flws), 
							   tokens: (token(idin, 0), tks), 
							   Atts > 
			=> < O : Process | nodes: (end(idnode, idin), nds), 
							   flows: (flow(idin, T), flws), 
							   tokens: tks, 
							   Atts > .


	rl [mergeExclusive] : < O : Process |  nodes: (merge(idnode, exclusive, (idin, ids), idout), nds), 
							  			   flows: (flow(idout, T), flws), 
							  			   tokens: (token(idin, 0), tks), 
							  			   Atts >
						=> < O : Process | nodes: (merge(idnode, exclusive, (idin, ids), idout), nds), 
										   flows: (flow(idout, T), flws), 
										   tokens: (token(idout, T), tks), 
										   Atts > .
    

	rl [splitExclusive] : < O : Process |  nodes: (split(idnode, exclusive, idin, (idout, ids)), nds), 
										   flows: (flow(idout, T), flws), 
										   tokens: (token(idin, 0), tks), 
										   Atts >
        				=> < O : Process | nodes: (split(idnode, exclusive, idin, (idout, ids)), nds), 
										   flows: (flow(idout, T), flws), 
										   tokens: (token(idout, T), tks), 
										   Atts > .


	crl [mergeParallel] : < O : Process |  nodes: (merge(idnode, parallel, (idin, ids), idout), nds), 
										   flows: (flow(idout, T), flws), 
										   tokens: (token(idin, 0), tks), 
										   Atts >
        				=> < O : Process | nodes: (merge(idnode, parallel, (idin, ids), idout), nds), 
										   flows: (flow(idout, T), flws), 
										   tokens: (token(idout, T), removeTokens(ids, tks)), 
										   Atts > 
        				if tokensOnFlowsTime(idnode, < O : Process | nodes: (merge(idnode, parallel, (idin, ids), idout), nds), 
																	 flows: (flow(idout, T), flws), 
																	 tokens: (token(idin, 0), tks), 
																	 Atts >) .


	rl [splitParallel] : < O : Process |   nodes: (split(idnode, parallel, idin, (idout, ids)), nds), 
										   flows: (flow(idout, T), flws),
										   tokens: (token(idin, 0), tks), 
										   Atts >
       					=> < O : Process | nodes: (split(idnode, parallel, idin, (idout, ids)), nds), 
										   flows: (flow(idout, T), flws), 
										   tokens: (token(idout, T), addTokens(ids, flws), tks), 
										   Atts > .
    

endm 




