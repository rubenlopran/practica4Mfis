*** Ruben 
*** Francisco de P. Arjona JimÃ©nez

sload time.maude


fmod ID is 
	protecting STRING .

	sort Id .
	op id : String -> Id [ctor] .
endfm 

view Id from TRIV to ID is	
	sort Elt to Id .
endv

fmod NODE is 
	protecting SET{Id} .
	protecting STRING .
	protecting TIME .

	sort Gateway Node .
	subsort Gateway < Node .
	
	op exclusive : -> Gateway [ctor] .
	op parallel : -> Gateway [ctor] .
	op start : Id Id -> Node [ctor] .
	op end : Id Id -> Node [ctor] .
	op task : Id String Id Id Time Set{Id} -> Node [ctor] .
	op split : Id Gateway Id Set{Id} -> Node [ctor] .
	op merge : Id Gateway Set{Id} Id -> Node [ctor] .
endfm

view Node from TRIV to NODE is	
	sort Elt to Node .
endv


fmod RESOURCE is 
	protecting ID .

	sort Resource .
	op resource : Id Nat Nat -> Resource [ctor] .
endfm

view Resource from TRIV to RESOURCE is	
	sort Elt to Resource .
endv


fmod FLOW is 
	protecting ID .
	protecting TIME .

	sort Flow .
	op flow : Id Time -> Flow [ctor] .
endfm

view Flow from TRIV to FLOW is	
	sort Elt to Flow .
endv


fmod TOKEN is 
	protecting ID .
	protecting TIME .

	sort Token .
	op token : Id Time -> Token [ctor] .
endfm

view Token from TRIV to TOKEN is	
	sort Elt to Token .
endv


mod PROCESS is
	including CONFIGURATION .
	protecting POSRAT-TIME-DOMAIN-WITH-INF .
	protecting ID .
	protecting SET{Node} .
	protecting SET{Flow} .
	protecting SET{Token} .
	protecting SET{Resource} .

	--- class Process | nodes: Set{Node},
	---					flows: Set{Flow},
	---					tokens: Set{Token},
	---					gtime: Time,
	---					resources: Set{Resource} .

	sort Process .
	subsort Process < Cid .

	op Process : -> Process .
	op nodes:_ : Set{Node} -> Attribute [gather (&)] .
    op flows:_ : Set{Flow} -> Attribute [gather (&)] .
    op tokens:_ : Set{Token} -> Attribute [gather (&)] .
    op gtime:_ : Time -> Attribute [gather (&)] .
	op resources:_ : Set{Resource} -> Attribute [gather (&)] .
endm

mod BPMN-SEM is
	protecting PROCESS .

	var name : String .
	var N M : Nat .
	vars idNODE idFLOWIN idFLOWOUT idAUX : Id .
	var O : Oid .
	var VProcess : Process .
	var setId : Set{Id} .
	var setNode : Set{Node} .
	var setFlow : Set{Flow} .
	var setToken : Set{Token} .
	var setResource : Set{Resource} .
	var Atts : AttributeSet .
	vars T T' T'' : Time .

	--- advance of time over a configuration
	op delta : Set{Token} Time -> Set{Token} .
	eq delta(empty, T) = empty .
	eq delta((token(idNODE, T'), setToken), T) = (token(idNODE, T' monus T),delta(setToken, T)) .

	--- maximum time elapse (so that no event is lost)
	op mte : Configuration -> TimeInf .
	eq mte(none) = INF .
	eq mte(< O : VProcess | nodes: setNode, 
							flows: setFlow, 
							tokens: empty, 
							Atts >) = INF .
	
	ceq mte(< O : VProcess | nodes: (task(idNODE, name, idFLOWIN, idFLOWOUT, T', setId),setNode), 
							 flows: (flow(idFLOWIN, T'), setFlow), 
							 tokens: (token(idFLOWIN, T), setToken), 
							 Atts >)
		= minimum(INF, mte(< O : VProcess | nodes: (task(idNODE, name, idFLOWIN, idFLOWOUT, T', setId),setNode), 
											flows: (flow(idFLOWIN, T'), setFlow), 
											tokens: setToken, 
											Atts >)) 
		if isBlockedTask(token(idFLOWIN, T),< O : VProcess | nodes: (task(idNODE, name, idFLOWIN, idFLOWOUT, T', setId),setNode), 
														flows: (flow(idFLOWIN, T'), setFlow), 
														tokens: (token(idFLOWIN, T), setToken), 
														Atts >) .

	ceq mte(< O : VProcess | nodes: (merge(idNODE, parallel, (idFLOWIN, setId), idFLOWOUT),setNode), 
							 flows: (flow(idFLOWIN, T''), setFlow), 
							 tokens: (token(idFLOWIN, 0), setToken), 
							 Atts >) 
        = minimum(INF, mte(< O : VProcess | nodes: (merge(idNODE, parallel, (idFLOWIN, setId), idFLOWOUT),setNode), 
											flows: (flow(idFLOWIN, T''), setFlow), 
											tokens: setToken, 
											Atts >)) 
        if isBlockedMerge(idNODE, < O : VProcess | nodes: (merge(idNODE, parallel, (idFLOWIN, setId), idFLOWOUT),setNode), 
												flows: (flow(idFLOWIN, T''), setFlow), 
												tokens: (token(idFLOWIN, 0), setToken), 
												Atts >) .
	
	eq mte(< O : VProcess | nodes: setNode, 
							flows: setFlow, 
							tokens: (token(idNODE, T), setToken), 
							Atts >)
		= minimum(T, mte(< O : VProcess | nodes: setNode, 
										  flows: setFlow, 
										  tokens: setToken, 
										  Atts >)) .


	op isBlockedTask : Token Configuration -> Bool .
    eq isBlockedTask(token(idFLOWIN, 0), < O : VProcess | nodes: (task(idNODE, name, idFLOWIN, idFLOWOUT, T', empty), setNode), 
													    resources: setResource,  
													    Atts >) 
					= false .

    ceq isBlockedTask(token(idFLOWIN, 0), < O : VProcess | nodes: (task(idNODE, name, idFLOWIN, idFLOWOUT, T', (idAUX, setId)), setNode), 
													     resources: (resource(idAUX, N, M),setResource),  
													     Atts >) 
					= true if M = 0 .

    eq isBlockedTask(token(idFLOWIN, 0), < O : VProcess | nodes: (task(idNODE, name, idFLOWIN, idFLOWOUT, T', (idAUX, setId)), setNode), 
														  resources: (resource(idAUX, N, M),setResource),  
														  Atts >) 
        			= isBlockedTask(token(idFLOWIN, 0), < O : VProcess | nodes: (task(idNODE, name, idFLOWIN, idFLOWOUT, T', setId), setNode), 
														   resources: (resource(idAUX, N, M),setResource),  
														   Atts >) . 


	op isBlockedMerge : Id Configuration -> Bool .
	eq isBlockedMerge(idNODE, < O : VProcess | nodes: (merge(idNODE, parallel, empty, idFLOWOUT), setNode), 
											flows: (flow(idFLOWOUT, T'), setFlow), 
											tokens: setToken, 
											Atts >) 
					= false .

	eq isBlockedMerge(idNODE, < O : VProcess | nodes: (merge(idNODE, parallel, (idFLOWIN, setId), idFLOWOUT), setNode), 
											flows: (flow(idFLOWOUT, T'), setFlow), 
											tokens: setToken, 
											Atts >) 
					= true .

    eq isBlockedMerge(idNODE, < O : VProcess | nodes: (merge(idNODE, parallel, (idFLOWIN, setId), idFLOWOUT), setNode), 
											flows: (flow(idFLOWOUT, T'), setFlow), 
											tokens: (token(idFLOWIN, 0), setToken), 
											Atts >) 
       				= isBlockedMerge(idNODE, < O : VProcess | nodes: (merge(idNODE, parallel, setId, idFLOWOUT), setNode), 
														   flows: (flow(idFLOWOUT, T'), setFlow), 
														   tokens: setToken, 
														   Atts >) .


	op addResource : Set{Id} Set{Resource} -> Set{Resource} .
	eq addResource(empty, setResource) = setResource . 
	eq addResource((idNODE, setId), (resource(idNODE, N, M),setResource)) = (resource(idNODE, N, s M), addResource(setId, setResource)) .


	op removeResource : Set{Id} Set{Resource} -> Set{Resource} .
	eq removeResource(empty, setResource) = setResource .
	eq removeResource((idNODE, setId), (resource(idNODE, N, M),setResource)) = (resource(idNODE, N, sd(M, 1)), removeResource(setId, setResource)) .


	op addTokens : Set{Id} Set{Flow} -> Set{Token} . 
    eq addTokens(empty, setFlow) = empty .
    eq addTokens((idNODE, setId), (flow(idNODE, T),setFlow)) = (token(idNODE, T), addTokens(setId, setFlow)) . 
    
    op removeTokens : Set{Id} Set{Token} -> Set{Token} .
    eq removeTokens(empty, setToken) = setToken .
    eq removeTokens((idNODE, setId), (token(idNODE, T),setToken)) = removeTokens(setId, setToken) .



	--- tick rule should not advance time beyond expiration of a timer
	crl [tick] : < O : VProcess | tokens: setToken, gtime: T, Atts > 
		=> < O : VProcess | tokens: delta(setToken, T'), gtime: T plus T', Atts > 
		if T' := mte(< O : VProcess | tokens: setToken, gtime: T, Atts >) /\ 0 < T' . ---/\ T < 100 . 


	--- para ir navegando, en los tokens ponemos el id y el T, destino->origen

	rl [start] : < O : VProcess | nodes: (start(idNODE, idFLOWOUT), setNode), 
								  flows: (flow(idFLOWOUT, T), setFlow), 
								  tokens: (token(idNODE, 0), setToken), 
								  Atts >
				=> < O : VProcess | nodes: (start(idNODE, idFLOWOUT), setNode), 
									flows: (flow(idFLOWOUT, T), setFlow), 
									tokens: (token(idFLOWOUT, T), setToken), 
									Atts > .

	crl [flowToTask] : < O : VProcess | nodes: (task(idNODE, name, idFLOWIN, idFLOWOUT, T', setId), setNode), 
										tokens: (token(idFLOWIN, 0), setToken), 
										resources: setResource, 
										Atts >
					=> < O : VProcess | nodes: (task(idNODE, name, idFLOWIN, idFLOWOUT, T', setId), setNode), 
										tokens: (token(idNODE, T'), setToken), 
										resources: removeResource(setId,setResource), 
										Atts > 
					if not(isBlockedTask(token(idFLOWIN, 0), < O : VProcess | nodes: (task(idNODE, name, idFLOWIN, idFLOWOUT, T', setId), setNode), 
																		 tokens: (token(idNODE, 0), setToken), 
																		 resources: setResource, 
																		 Atts >)) .

	rl [task] : < O : VProcess | nodes: (task(idNODE, name, idFLOWIN, idFLOWOUT, T', setId), setNode), 
								 flows: (flow(idFLOWOUT, T''), setFlow), 
								 tokens: (token(idNODE, 0), setToken), 
								 resources: setResource, Atts >
					=> < O : VProcess | nodes: (task(idNODE, name, idFLOWIN, idFLOWOUT, T', setId), setNode), 
										flows: (flow(idFLOWOUT, T''), setFlow), 
										tokens: (token(idFLOWOUT, T''), setToken), 
										resources: addResource(setId, setResource), 
										Atts > .

	rl [end] : < O : VProcess | nodes: (end(idNODE, idFLOWIN), setNode), 
								flows: (flow(idFLOWIN, T), setFlow), 
								tokens: (token(idFLOWIN, 0), setToken), 
								Atts > 
			=> < O : VProcess | nodes: (end(idNODE, idFLOWIN), setNode), 
								flows: (flow(idFLOWIN, T), setFlow), 
								tokens: setToken, 
								Atts > .

	rl [mergeExclusive] : < O : VProcess |  nodes: (merge(idNODE, exclusive, (idFLOWIN, setId), idFLOWOUT), setNode), 
							  				flows: (flow(idFLOWOUT, T'), setFlow), 
							  				tokens: (token(idFLOWIN, 0), setToken), 
							  				Atts >
						=> < O : VProcess | nodes: (merge(idNODE, exclusive, (idFLOWIN, setId), idFLOWOUT), setNode), 
											flows: (flow(idFLOWOUT, T'), setFlow), 
											tokens: (token(idFLOWOUT, T'), setToken), 
											Atts > .
    
	rl [splitExclusive] : < O : VProcess |  nodes: (split(idNODE, exclusive, idFLOWIN, (idFLOWOUT, setId)), setNode), 
											flows: (flow(idFLOWOUT, T''), setFlow), 
											tokens: (token(idFLOWIN, 0), setToken), 
											Atts >
        				=> < O : VProcess | nodes: (split(idNODE, exclusive, idFLOWIN, (idFLOWOUT, setId)), setNode), 
											flows: (flow(idFLOWOUT, T''), setFlow), 
											tokens: (token(idFLOWOUT, T''), setToken), 
											Atts > .

	crl [mergeParallel] : < O : VProcess |  nodes: (merge(idNODE, parallel, (idFLOWIN, setId), idFLOWOUT), setNode), 
											flows: (flow(idFLOWOUT, T'), setFlow), 
											tokens: (token(idFLOWIN, 0), setToken), 
											Atts >
        				=> < O : VProcess | nodes: (merge(idNODE, parallel, (idFLOWIN, setId), idFLOWOUT), setNode), 
											flows: (flow(idFLOWOUT, T'), setFlow), 
											tokens: (token(idFLOWOUT, T'), removeTokens(setId, setToken)), 
											Atts > 
        				if not(isBlockedMerge(idNODE, < O : VProcess | nodes: (merge(idNODE, parallel, (idFLOWIN, setId), idFLOWOUT), setNode), 
																	flows: (flow(idFLOWOUT, T'), setFlow), 
																	tokens: (token(idFLOWIN, 0), setToken), 
																	Atts >)) .

	rl [splitParallel] : < O : VProcess |   nodes: (split(idNODE, parallel, idFLOWIN, (idFLOWOUT, setId)), setNode), 
											flows: (flow(idFLOWOUT, T''), setFlow),
											tokens: (token(idFLOWIN, 0), setToken), 
											Atts >
       					=> < O : VProcess | nodes: (split(idNODE, parallel, idFLOWIN, (idFLOWOUT, setId)), setNode), 
											flows: (flow(idFLOWOUT, T''), setFlow), 
											tokens: (token(idFLOWOUT, T''), addTokens(setId, setFlow), setToken), 
											Atts > .
    

endm 




