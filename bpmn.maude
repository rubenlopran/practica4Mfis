*** Ruben 
*** Francisco de P. Arjona JimÃ©nez

sload time.maude


fmod ID is 
	protecting STRING .

	sort Id .
	op id : String -> Id [ctor] .
endfm 

view Id from TRIV to ID is	
	sort Elt to Id .
endv

fmod NODE is 
	protecting SET{Id} .
	protecting STRING .
	protecting TIME .

	sort Gateway Node .
	subsort Gateway < Node .
	
	op exclusive : -> Gateway [ctor] .
	op parallel : -> Gateway [ctor] .
	op start : Id Id -> Node [ctor] .
	op end : Id Id -> Node [ctor] .
	op task : Id String Id Id Time Set{Id} -> Node [ctor] .
	op split : Id Gateway Id Set{Id} -> Node [ctor] .
	op merge : Id Gateway Set{Id} Id -> Node [ctor] .
endfm

view Node from TRIV to NODE is	
	sort Elt to Node .
endv


fmod RESOURCE is 
	protecting ID .

	sort Resource .
	op resource : Id Nat Nat -> Resource [ctor] .
endfm

view Resource from TRIV to RESOURCE is	
	sort Elt to Resource .
endv


fmod FLOW is 
	protecting ID .
	protecting TIME .

	sort Flow .
	op flow : Id Time -> Flow [ctor] .
endfm

view Flow from TRIV to FLOW is	
	sort Elt to Flow .
endv


fmod TOKEN is 
	protecting ID .
	protecting TIME .

	sort Token .
	op token : Id Time -> Token [ctor] .
endfm

view Token from TRIV to TOKEN is	
	sort Elt to Token .
endv


mod PROCESS is
	including CONFIGURATION .
	protecting POSRAT-TIME-DOMAIN-WITH-INF .
	protecting ID .
	protecting SET{Node} .
	protecting SET{Flow} .
	protecting SET{Token} .
	protecting SET{Resource} .

	--- class Process | nodes: Set{Node},
	---					flows: Set{Flow},
	---					tokens: Set{Token},
	---					gtime: Time,
	---					resources: Set{Resource} .

	sort Process .
	subsort Process < Cid .

	op Process : -> Process .
	op nodes:_ : Set{Node} -> Attribute [gather (&)] .
    op flows:_ : Set{Flow} -> Attribute [gather (&)] .
    op tokens:_ : Set{Token} -> Attribute [gather (&)] .
    op gtime:_ : Time -> Attribute [gather (&)] .
	op resources:_ : Set{Resource} -> Attribute [gather (&)] .
endm

mod BPMN-SEM is
	protecting PROCESS .

	var name : String .
	var N M : Nat .
	vars id1 id2 id3 id4 : Id .
	var O : Oid .
	var VProcess : Process .
	var setId : Set{Id} .
	var setNode : Set{Node} .
	var setFlow : Set{Flow} .
	var setToken : Set{Token} .
	var setResource : Set{Resource} .
	var Atts : AttributeSet .
	vars T T' T'' : Time .

	--- advance of time over a configuration
	op delta : Set{Token} Time -> Set{Token} .
	eq delta(empty, T) = empty .
	eq delta((token(id1, T'), setToken), T) = (token(id1, T' monus T),delta(setToken, T)) .

	--- maximum time elapse (so that no event is lost)
	op mte : Configuration -> TimeInf .
	eq mte(none) = INF .
	eq mte(< O : VProcess | nodes: setNode, flows: setFlow, tokens: empty, Atts >) = INF .
	---ceq mte(< O : VProcess | nodes: (task(id2, name, id1, id3, T', setId),setNode), flows: (flow(id1, T'), setFlow), tokens: (token(id1, T), setToken), Atts >)
	---	= minimum(INF, mte(< O : VProcess | nodes: (task(id2, name, id1, id3, T', setId),setNode), flows: (flow(id1, T'), setFlow), tokens: setToken, Atts >)) 
	---	if isBlockedTask(token(id1, T),< O : VProcess | nodes: (task(id2, name, id1, id3, T', setId),setNode), flows: (flow(id1, T'), setFlow), tokens: (token(id1, T), setToken), Atts >) .
	eq mte(< O : VProcess | nodes: setNode, flows: setFlow, tokens: (token(id1, T), setToken), Atts >)
		= minimum(T, mte(< O : VProcess | nodes: setNode, flows: setFlow, tokens: setToken, Atts >)) .


	op isBlockedTask : Token Configuration -> Bool .
    eq isBlockedTask(token(id1, 0), < O : VProcess | nodes: (task(id2, name, id1, id3, T', empty), setNode), resources: setResource,  Atts >) = false .
    ceq isBlockedTask(token(id1, 0), < O : VProcess | nodes: (task(id2, name, id1, id3, T', (id4, setId)), setNode), resources: (resource(id4, N, M),setResource),  Atts >) = true 
        if M = 0 .
    eq isBlockedTask(token(id1, 0), < O : VProcess | nodes: (task(id2, name, id1, id3, T', (id4, setId)), setNode), resources: (resource(id4, N, M),setResource),  Atts >) = 
        isBlockedTask(token(id1, 0), < O : VProcess | nodes: (task(id2, name, id1, id3, T', setId), setNode), resources: (resource(id4, N, M),setResource),  Atts >) . 


	op addResource : Set{Id} Set{Resource} -> Set{Resource} .
	eq addResource(empty, setResource) = setResource . 
	eq addResource((id1, setId), (resource(id1, N, M),setResource)) = (resource(id1, N, s M), addResource(setId, setResource)) .


	op removeResource : Set{Id} Set{Resource} -> Set{Resource} .
	eq removeResource(empty, setResource) = setResource .
	eq removeResource((id1, setId), (resource(id1, N, M),setResource)) = (resource(id1, N, sd(M, 1)), removeResource(setId, setResource)) .


	--- tick rule should not advance time beyond expiration of a timer
	crl [tick] : < O : VProcess | tokens: setToken, gtime: T, Atts > 
		=> < O : VProcess | tokens: delta(setToken, T'), gtime: T plus T', Atts > 
		if T' := mte(< O : VProcess | tokens: setToken, gtime: T, Atts >) /\ 0 < T' . --- /\ T < 100 . 

	rl [start] : < O : VProcess | nodes: (start(id1, id2), setNode), flows: (flow(id2, T), setFlow), tokens: (token(id1, 0), setToken), Atts >
		=> < O : VProcess | nodes: (start(id1, id2), setNode), flows: (flow(id2, T), setFlow), tokens: (token(id2, T), setToken), Atts > .

	crl [flowToTask] : < O : VProcess | nodes: (task(id2, name, id1, id3, T', setId), setNode), tokens: (token(id1, 0), setToken), resources: setResource, Atts >
		=> < O : VProcess | nodes: (task(id2, name, id1, id3, T', setId), setNode), tokens: (token(id2, T'), setToken), resources: removeResource(setId,setResource), Atts > 
		if not(isBlockedTask(token(id1, 0), < O : VProcess | nodes: (task(id2, name, id1, id3, T', setId), setNode), tokens: (token(id2, 0), setToken), resources: setResource, Atts >)) .

	rl [task] : < O : VProcess | nodes: (task(id2, name, id1, id3, T', setId), setNode), flows: (flow(id3, T''), setFlow), tokens: (token(id2, 0), setToken), resources: setResource, Atts >
		=> < O : VProcess | nodes: (task(id2, name, id1, id3, T', setId), setNode), flows: (flow(id3, T''), setFlow), tokens: (token(id3, T''), setToken), resources: addResource(setId, setResource), Atts > .

	rl [end] : < O : VProcess | nodes: (end(id2, id1), setNode), flows: (flow(id1, T), setFlow), tokens: (token(id1, 0), setToken), Atts > 
		=> < O : VProcess | nodes: (end(id2, id1), setNode), flows: (flow(id1, T), setFlow), tokens: setToken, Atts > .

	rl [mergeExclusive] : < O : VProcess | nodes: (merge(id1, exclusive, (id3, setId), id2), setNode), flows: (flow(id2, T'), setFlow), tokens: (token(id3, 0), setToken), Atts >
		=> < O : VProcess | nodes: (merge(id1, exclusive, (id3, setId), id2), setNode), flows: (flow(id2, T'), setFlow), tokens: (token(id2, T'), setToken), Atts > .
    
	rl [splitExclusive] : < O : VProcess | nodes: (split(id2, exclusive, id1, (id3, setId)), setNode), flows: (flow(id3, T''), setFlow), tokens: (token(id1, 0), setToken), Atts >
        => < O : VProcess | nodes: (split(id2, exclusive, id1, (id3, setId)), setNode), flows: (flow(id3, T''), setFlow), tokens: (token(id3, T''), setToken), Atts > .


endm 




